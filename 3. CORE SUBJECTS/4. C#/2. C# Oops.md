# C# Opps
- C++ is an object-oriented programming language.

# Create an Object
- ```java
  class MyClass {       // The class
  public:             // Access specifier
    int myNum;        // Attribute (int variable)
    string myString;  // Attribute (string variable)
  };

  int main() {
  MyClass myObj;  // Create an object of MyClass

  // Access attributes and set values
  myObj.myNum = 15; 
  myObj.myString = "Some text";

  // Print attribute values
  cout << myObj.myNum << "\n";
  cout << myObj.myString;
  return 0;
  }
  ```
# Methods
- To define a function outside the class definition, you have to declare it inside the class and then define it outside of the class.
  This is done by specifiying the name of the class, followed the scope resolution `::` operator, followed by the name of the function:
- ```java
  class MyClass {        // The class
  public:              // Access specifier
    void myMethod();   // Method/function declaration
  };

  // Method/function definition outside the class
  void MyClass::myMethod() {
  cout << "Hello World!";
  }

  int main() {
  MyClass myObj;     // Create an object of MyClass
  myObj.myMethod();  // Call the method
  return 0;
  }
  ```
# Constructor
- A constructor in C++ is a special method that is automatically called when an object of a class is created.
  The constructor has the same name as the class, it is always public, and it does not have any return value.
  To create a constructor, use the same name as the class, followed by parentheses ():
- ```java
  class MyClass {     // The class
  public:           // Access specifier
    MyClass() {     // Constructor
      cout << "Hello World!";
    }
  };

  int main() {
  MyClass myObj;    // Create an object of MyClass (this will call the constructor)
  return 0;
  }
  ```

# Encapsulation:
- The meaning of Encapsulation, is to make sure that `"sensitive"` data is hidden from users. To achieve this, you must:
  - declare fields/variables as `private`
  - provide `public get` and `set` methods, through properties, to access and update the value of a `private` field

- ```java
   class Person
  {
    private string name; // field
    public string Name   // property
    {
      get { return name; }
      set { name = value; }
    }
  }

  class Program
  {
    static void Main(string[] args)
    {
    Person myObj = new Person();
    myObj.Name = "Liam";
    Console.WriteLine(myObj.Name);
    }
  }
  ```

## Why Encapsulation?
- Better control of class members (reduce the possibility of yourself (or others) to mess up the code)
- Fields can be made `read-only` (if you only use the get method), or `write-only` (if you only use the set method)
- `Flexible:` the programmer can change one part of the code without affecting other parts
- Increased security of data

# Inheritance:
- In C#, it is possible to inherit fields and methods from one class to another. We group the `"inheritance concept"` into two categories:
  - `Derived Class (child)` - the class that inherits from another class
  - `Base Class (parent)` - the class being inherited from
- To inherit from a class, use the `:` symbol.

- ```java
  class Vehicle  // base class (parent) 
  {
    public string brand = "Ford";  // Vehicle field
    public void honk()             // Vehicle method 
    {                    
      Console.WriteLine("Tuut, tuut!");
    }
  }

  class Car : Vehicle  // derived class (child)
  {
    public string modelName = "Mustang";  // Car field
  }

  class Program
  {
    static void Main(string[] args)
    {
    // Create a myCar object
    Car myCar = new Car();

    // Call the honk() method (From the Vehicle class) on the myCar object
    myCar.honk();

    // Display the value of the brand field (from the Vehicle class) and the value of the modelName from the Car class
    Console.WriteLine(myCar.brand + " " + myCar.modelName);
    }
  }
  ```

## Why And When To Use "Inheritance"?
- It is useful for `code reusability:` reuse fields and methods of an existing class when you create a new class.

# Polymorphism:
- Polymorphism means `"many forms"`, and it occurs when we have many classes that are related to each other by inheritance.
## Method Overriding-
- ```java
   class Animal  // Base class (parent) 
   {
      public virtual void animalSound() 
      {
         Console.WriteLine("The animal makes a sound");
      }
   }

  class Pig : Animal  // Derived class (child) 
  {
     public override void animalSound() 
    {
      Console.WriteLine("The pig says: wee wee");
    }
  }

  class Dog : Animal  // Derived class (child) 
  {
    public override void animalSound() 
    {
      Console.WriteLine("The dog says: bow wow");
    }
  }

   class Program 
  {
      static void Main(string[] args) 
    {
        Animal myAnimal = new Animal();  // Create a Animal object
        Animal myPig = new Pig();  // Create a Pig object
        Animal myDog = new Dog();  // Create a Dog object

        myAnimal.animalSound();
        myPig.animalSound();
        myDog.animalSound();
    }
  }
  ```

## Why And When To Use "Inheritance" and "Polymorphism"?
- It is useful for code `reusability:` reuse fields and methods of an existing class when you create a new class.
